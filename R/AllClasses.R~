#' clusterdef class
#'
#' Defines parameters used to describe location and spread of clusters.
#'
#' The definition is split into two parts.  This separation allows us
#' to define n clusters which depend on 4xm parameters (m is less than
#' n), so that clusters with equal total copy number can share the
#' same mean R, for example.
#'
#' \section{Cluster specific slots}{
#'  \describe{
#' 
#'    \item{\code{a1}:}{Count of allele 1}
#' 
#'    \item{\code{a2}:}{Count of allele 2}
#' 
#'    \item{\code{R.index}:}{ index of the R parameters that define the location of this cluster}
#' 
#'    \item{\code{theta.index}:}{ index of the theta parameters that define the location of this cluster}
#' 
#'  }
#' }
#' 
#' \section{Parameter slots}{
#' 
#'  \describe{
#'    \item{\code{R.mean}:}{ numeric vector, element i defines the mean of the gaussian distribution from which R values for clusters with R.index==i are selected}
#' 
#'    \item{\code{R.sd}:}{ numeric vector, element i defines the sd of the gaussian distribution from which R values for clusters with R.index==i are selected}
#' 
#'    \item{\code{theta.a}:}{ numeric vector, element i defines the shape 1 parameter of the beta distribution from which theta values for clusters with theta.index==i are selected}
#' 
#'    \item{\code{theta.b}:}{ numeric vector, element i defines the shape2 parameter of the beta distribution from which theta values for clusters with theta.index==i are selected}
#'  }
#' }
#' @name clusterdef-class
#' @rdname clusterdef-class
#' @exportClass clusterdef
#' @docType Class
setClass("clusterdef",
         slots=c(a1="numeric",
           a2="numeric",
           pi="numeric",
           R.index="numeric",
           theta.index="numeric",
           R.mean="numeric",
           R.sd="numeric",
           theta.a="numeric",
           theta.b="numeric",
           R.opt="logical",
           theta.opt="logical"),
         validity=function(object) {
           n <- length(object@a1)
           if(length(object@a2)!=n ||
              length(object@R.index)!=n ||
              length(object@theta.index)!=n ||
              length(object@pi)!=n)
             stop("a1, a2, R.index, theta.index, pi need to be of equal length")
           m <- max(object@R.index, na.rm=TRUE)
           if(length(object@R.mean)!=m ||
              length(object@R.sd)!=m)
             stop("not all indices in R.index given in R.mean, R.sd")
           m <- max(object@theta.index, na.rm=TRUE)
          if(length(object@theta.a)!=m ||
              length(object@theta.b)!=m)
             stop("not all indices in theta.index given in theta.a, theta.b")
         })


setClass("clusterfit",
         slots=c(theta="numeric",
             lrr="numeric",
             pp="matrix",
             fit.info="numeric"),
         contains="clusterdef",
         validity=function(object) {
           n <- length(object@theta)
           if(length(object@lrr)!=n ||
              nrow(object@pp) != n)
             stop("theta and lrr must have length == nrow(pp)")
             stop("not all indices in theta.index given in theta.a, theta.b")
         })


