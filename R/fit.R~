beta.em <- function(df.in,x,y,tol=1e-2,verbose=FALSE,maxit=1e4, eps=1e-2, use.deriv=FALSE) {
  library(RColorBrewer)
  mx <- NULL
  p <- df.in@pi
  ngroup <- length(p)

  ## x \in (0,1)
  x[ x<=0 ] <- eps
  x[ x>=1 ] <- 1-eps

  dfsumm <- summary(df.in)

  ## probabilities of group membership
  px <- matrix(dfsumm$pi,length(x),ngroup,byrow=TRUE)
  ## parameter vector
  pars <- c(a=df.in@theta.a[ df.in@theta.opt ], b=df.in@theta.b[ df.in@theta.opt ])


  ## define lots of functions within this function to use dfsumm environment  
  ## vectors of a, b
  abvec <- function(pars) {
    a <- pars[grep("a",names(pars))]
    b <- pars[grep("b",names(pars))]
    avec <- a[dfsumm$theta.index]
    bvec <- b[dfsumm$theta.index]
    avec[ dfsumm$copies==0 ] <- bvec[ dfsumm$copies==0 ] <- 1
    return(list(a=avec,b=bvec))
  }
  
  ## likelihood for a single group
  lhood.single <- function(avec, bvec, x, y, pi, i) {
    if(i>length(avec) || i>length(bvec))
      stop("cannot estimate likelihood for more than",length(a),"groups")
    dbeta(x,shape1=avec[i],shape2=bvec[i]) * dnorm(y,mean=dfsumm$R.mean[i],sd=dfsumm$R.sd[i]) * pi
  }


  ## likelihood function to be maximized
  lhood <- function(pars, x, y, px, sumlog=TRUE) {
    if(any(pars<0)) # a > 0, b > 0
      return(NA)
    ab <- abvec(pars)    
    ngroup <- length(ab$a)
    e <- rep(0,length(x))
    for(i in 1:ngroup) {
      ##    cat(i, (dbeta(x,a[i],b[i]) * dnorm(y,mu[i],sigma[i]) * p[,i])[wh], "\n")
      e <- e + lhood.single(ab$a, ab$b, x, y, px[,i], i)
    }
    if(!any(is.na(e)) & any(e==0)) {
      wh <- which(e==0)
      e[wh] <- 1e-64
    }
    if(!any(is.na(e)) & any(is.infinite(e))) {
      wh <- which(is.infinite(e))
      e[wh] <- 1e64
    }
    if(sumlog) {
      return(-sum(log(e)))
    } else {
      return(-e)
    }
  }

  ## TODO: use logs
  dab.single <- function(a, b, x, y, pi) {
    B <- lbeta(a,b)
    C <- dnorm(y,mean=dfsumm$R.mean[i],sd=dfsumm$R.sd[i],log=TRUE) +
             log(pi) + (b - 1)*log(1-x) + (a-1)*log(x) - 2*B
    list(a= C + log(log(x) * exp(B) - digamma(a) + digamma(a+b)),
         b= C + log(log(1-x) * exp(B) - digamma(a) + digamma(a+b)))
  }
  
  deriv <- function(pars, x, y, px) {
    if(any(pars<0)) # a > 0, b > 0
      return(NA)
    ab <- abvec(pars)    
    ngroup <- length(ab$a)
    deriv.a <- deriv.b <- numeric(length(pars)/2)
    ea <- eb <- matrix(0,length(x),length(ab$a))
    for(j in unique(dfsumm$theta.index[ dfsumm$theta.opt ])) {
      for(i in (1:nrow(dfsumm))[ dfsumm$theta.index==j & dfsumm$theta.opt ]) {
        tmp <- dab.single(ab$a[i], ab$b[i], x, y, px[,i])
      ea[,j] <- logsum(ea[,j],tmp$a)
      eb[,j] <- logsum(eb[,j],tmp$b)
    }
    L <- lhood(pars, x, y, px, sumlog=FALSE)
    c(colSums(ea/L),colSums(eb/L))
    #ret[ kk==0 ] <- 0
  }
 deriv(pars,x,y,px)

  ## now start the work
  
  nit <- 0
  df <- 1
  cols <- brewer.pal(ngroup, "Paired")
#  hwe <- ngroup>1
  hwe <- FALSE
  value <- numeric(maxit)
  while(hwe | (df>tol & nit<maxit)) {

 ##    if(df<tol & nit<maxit) { # relax hwe condition
##       hwe <- FALSE
##       nit <- 0
##     }

    nit <- nit+1
    
    ab <- abvec(pars)    
   
    ## E step
    if(ngroup>1) { # px=1 for ngroup==1
      px.old <- px
      p <- colMeans(px)
      for(i in 1:ngroup) {
        px[,i] <- lhood.single(ab$a, ab$b, x, y, p[i], i)
      }
      px <- px/rowSums(px) ## normalise
      if(any(is.nan(px)))
        px[is.nan(px)] <- 0
      df <- max(abs(px-px.old))
    } else {
      df <- 0 # no point iterating over an E step that doesn't change
    }

    ## M step
    p <- colMeans(px)
 ##    if(hwe) {
##       pi <- (2*p[1]+p[2])/2
##       p <- c(pi^2,2*pi*(1-pi),(1-pi)^2)      
##     }
##     mx <- try(optim(par=pars,
##                     fn=lhood,
##                     x=x,y=y,px=px))
    if(use.deriv) {
      mx <- try(optim(par=pars,
                      fn=lhood,
                      gr=deriv,
                      x=x,y=y,px=px))
    } else {
      mx <- try(optim(par=pars,
                      fn=lhood,
                      x=x,y=y,px=px))
    }
    value[i] <- mx$value
    pars <- mx$par
    if(inherits(mx,"try-error")) {
      mx <- NULL
      next
    }
    cat(nit,value[i],"\n")
  }
  ab <- abvec(mx$par)
  df.out <- df.in
  df.out@theta.a[ df.out@theta.opt ] <- mx$par[ grep("a",names(mx$par)) ]
  df.out@theta.b[ df.out@theta.opt ] <- mx$par[ grep("b",names(mx$par)) ]
  df.out@pi <- colMeans(px)
  return(list(clusters=df.out,
              lhood=value[1:nit]))
}

##' .. content for \description{} (no empty lines) ..
##'
##' .. content for \details{} ..
##' @title 
##' @param x beta variable
##' @param y gaussian variable
##' @param id 
##' @param ngroup 
##' @param inits 
##' @param limits 
##' @param method 
##' @param plot.hist 
##' @return 
##' @author Chris Wallace
fitbeta <- function(x,y,df,eps=1e-4) {
## id="",ngroup=3,inits,
##                     limits,method="em",plot.hist=TRUE
  ## overall fitting function
  ngroup <- nrow(df)

  ## x \in (0,1)
  x[ x<=0 ] <- eps
  x[ x>=1 ] <- 1-eps
  
#  if(method=="em") {
  mix <- beta.em(df,x,y)
#  }

##   ## reorder mix$par
##   mix$par <- c(mix$par[grep("p",names(mix$par))],
##                mix$par[grep("a",names(mix$par))],
##                mix$par[grep("b",names(mix$par))])

  df$alpha <- mix$par[ grep("a",names(mix$par)) ]
  df$beta <- mix$par[ grep("b",names(mix$par)) ]
  df$pi <- mix$par[ grep("p",names(mix$par)) ]
  return(df)
}
